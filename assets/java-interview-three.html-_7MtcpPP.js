import{_ as n}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as s,e}from"./app-9Gb0doIl.js";const t={},i=e(`<h2 id="_4-java-io" tabindex="-1"><a class="header-anchor" href="#_4-java-io" aria-hidden="true">#</a> 4 Java IO</h2><blockquote><p>Java IO 相关</p></blockquote><h3 id="_4-1-基础-io" tabindex="-1"><a class="header-anchor" href="#_4-1-基础-io" aria-hidden="true">#</a> 4.1 基础 IO</h3><h4 id="如何从数据传输方式理解-io-流" tabindex="-1"><a class="header-anchor" href="#如何从数据传输方式理解-io-流" aria-hidden="true">#</a> 如何从数据传输方式理解 IO 流？</h4><p>从数据传输方式或者说是运输方式角度看，可以将 IO 类分为:</p><ol><li><strong>字节流</strong>, 字节流读取单个字节，字符流读取单个字符(一个字符根据编码的不同，对应的字节也不同，如 UTF-8 编码是 3 个字节，中文编码是 2 个字节。)</li><li><strong>字符流</strong>, 字节流用来处理二进制文件(图片、MP3、视频文件)，字符流用来处理文本文件(可以看做是特殊的二进制文件，使用了某种编码，人可以阅读)。</li></ol><p><strong>字节是个计算机看的，字符才是给人看的</strong></p><ul><li><strong>字节流</strong></li></ul><p><img src="https://exchange-imgs2021.oss-cn-beijing.aliyuncs.com/img/20220404213352.png" alt=""></p><ul><li><strong>字符流</strong></li></ul><p><img src="https://exchange-imgs2021.oss-cn-beijing.aliyuncs.com/img/20220404213426.png" alt=""></p><ul><li><strong>字节转字符</strong>？</li></ul><p><img src="https://exchange-imgs2021.oss-cn-beijing.aliyuncs.com/img/20220404213501.png" alt=""></p><h4 id="如何从数据操作上理解-io-流" tabindex="-1"><a class="header-anchor" href="#如何从数据操作上理解-io-流" aria-hidden="true">#</a> 如何从数据操作上理解 IO 流？</h4><p>从数据来源或者说是操作对象角度看，IO 类可以分为:</p><p><img src="https://exchange-imgs2021.oss-cn-beijing.aliyuncs.com/img/20220404213524.png" alt=""></p><h4 id="java-io-设计上使用了什么设计模式" tabindex="-1"><a class="header-anchor" href="#java-io-设计上使用了什么设计模式" aria-hidden="true">#</a> Java IO 设计上使用了什么设计模式？</h4><p><strong>装饰者模式</strong>： 所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。</p><ul><li><strong>装饰着举例</strong></li></ul><p>设计不同种类的饮料，饮料可以添加配料，比如可以添加牛奶，并且支持动态添加新配料。每增加一种配料，该饮料的价格就会增加，要求计算一种饮料的价格。</p><p>下图表示在 DarkRoast 饮料上新增新添加 Mocha 配料，之后又添加了 Whip 配料。DarkRoast 被 Mocha 包裹，Mocha 又被 Whip 包裹。它们都继承自相同父类，都有 cost() 方法，外层类的 cost() 方法调用了内层类的 cost() 方法。</p><p><img src="https://exchange-imgs2021.oss-cn-beijing.aliyuncs.com/img/20220404213552.png" alt=""></p><p><strong>以 InputStream 为例</strong></p><ul><li>InputStream 是抽象组件；</li><li>FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作；</li><li>FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。</li></ul><p><img src="https://exchange-imgs2021.oss-cn-beijing.aliyuncs.com/img/20220404213621.png" alt=""></p><p>实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">FileInputStream</span> fileInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">BufferedInputStream</span> bufferedInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span>fileInputStream<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>DataInputStream 装饰者提供了对更多数据类型进行输入的操作，比如 int、double 等基本类型。</p><h3 id="_4-2-5-种-io-模型" tabindex="-1"><a class="header-anchor" href="#_4-2-5-种-io-模型" aria-hidden="true">#</a> 4.2 5 种 IO 模型</h3><h4 id="什么是阻塞-什么是同步" tabindex="-1"><a class="header-anchor" href="#什么是阻塞-什么是同步" aria-hidden="true">#</a> 什么是阻塞？什么是同步？</h4><ul><li><strong>阻塞 IO 和 非阻塞 IO</strong></li></ul><p>这两个概念是<strong>程序级别</strong>的。主要描述的是程序请求操作系统 IO 操作后，如果 IO 资源没有准备好，那么程序该如何处理的问题: 前者等待；后者继续执行(并且使用线程一直轮询，直到有 IO 资源准备好了)</p><ul><li><strong>同步 IO 和 非同步 IO</strong></li></ul><p>这两个概念是<strong>操作系统级别</strong>的。主要描述的是操作系统在收到程序请求 IO 操作后，如果 IO 资源没有准备好，该如何响应程序的问题: 前者不响应，直到 IO 资源准备好以后；后者返回一个标记(好让程序和自己知道以后的数据往哪里通知)，当 IO 资源准备好以后，再用事件机制返回给程序。</p><h4 id="什么是-linux-的-io-模型" tabindex="-1"><a class="header-anchor" href="#什么是-linux-的-io-模型" aria-hidden="true">#</a> 什么是 Linux 的 IO 模型？</h4><p>网络 IO 的本质是 socket 的读取，socket 在 linux 系统被抽象为流，IO 可以理解为对流的操作。刚才说了，对于一次 IO 访问（以 read 举例），<strong>数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间</strong>。所以说，当一个 read 操作发生时，它会经历两个阶段：</p><ul><li>第一阶段：等待数据准备 (Waiting for the data to be ready)。</li><li>第二阶段：将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)。</li></ul><p>对于 socket 流而言，</p><ul><li>第一步：通常涉及等待网络上的数据分组到达，然后被复制到内核的某个缓冲区。</li><li>第二步：把数据从内核缓冲区复制到应用进程缓冲区。</li></ul><p>网络应用需要处理的无非就是两大类问题，网络 IO，数据计算。相对于后者，网络 IO 的延迟，给应用带来的性能瓶颈大于后者。网络 IO 的模型大致有如下几种：</p><ol><li>同步阻塞 IO（bloking IO）</li><li>同步非阻塞 IO（non-blocking IO）</li><li>多路复用 IO（multiplexing IO）</li><li>信号驱动式 IO（signal-driven IO）</li><li>异步 IO（asynchronous IO）</li></ol><p><img src="https://exchange-imgs2021.oss-cn-beijing.aliyuncs.com/img/20220404214028.png" alt=""></p><p>PS: 这块略复杂，在后面的提供了问答，所以用了最简单的举例结合 Linux IO 图例帮你快速理解。@pdai</p><h4 id="什么是同步阻塞-io" tabindex="-1"><a class="header-anchor" href="#什么是同步阻塞-io" aria-hidden="true">#</a> 什么是同步阻塞 IO？</h4><p>应用进程被阻塞，直到数据复制到应用进程缓冲区中才返回。</p><ul><li><strong>举例理解</strong></li></ul><p>你早上去买有现炸油条，你点单，之后一直等店家做好，期间你啥其它事也做不了。（你就是应用级别，店家就是操作系统级别， 应用被阻塞了不能做其它事）</p><ul><li><strong>Linux 中 IO 图例</strong></li></ul><p><img src="https://exchange-imgs2021.oss-cn-beijing.aliyuncs.com/img/20220404214056.png" alt=""></p><h4 id="什么是同步非阻塞-io" tabindex="-1"><a class="header-anchor" href="#什么是同步非阻塞-io" aria-hidden="true">#</a> 什么是同步非阻塞 IO？</h4><p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询(polling)。</p><ul><li><strong>举例理解</strong></li></ul><p>你早上去买现炸油条，你点单，点完后每隔一段时间询问店家有没有做好，期间你可以做点其它事情。（你就是应用级别，店家就是操作系统级别，应用可以做其它事情并通过轮询来看操作系统是否完成）</p><ul><li><strong>Linux 中 IO 图例</strong></li></ul><p><img src="https://exchange-imgs2021.oss-cn-beijing.aliyuncs.com/img/20220404214141.png" alt=""></p><h4 id="什么是多路复用-io" tabindex="-1"><a class="header-anchor" href="#什么是多路复用-io" aria-hidden="true">#</a> 什么是多路复用 IO？</h4><p>系统调用可能是由多个任务组成的，所以可以拆成多个任务，这就是多路复用。</p><ul><li><strong>举例理解</strong></li></ul><p>你早上去买现炸油条，点单收钱和炸油条原来都是由一个人完成的，现在他成了瓶颈，所以专门找了个收银员下单收钱，他则专注在炸油条。（本质上炸油条是耗时的瓶颈，将他职责分离出不是瓶颈的部分，比如下单收银，对应到系统级别也时一样的意思）</p><ul><li><strong>Linux 中 IO 图例</strong></li></ul><p>使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读，这一过程会被阻塞，当某一个套接字可读时返回。之后再使用 recvfrom 把数据从内核复制到进程中。</p><p>它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。</p><p><img src="https://exchange-imgs2021.oss-cn-beijing.aliyuncs.com/img/20220404214204.png" alt=""></p><h4 id="有哪些多路复用-io" tabindex="-1"><a class="header-anchor" href="#有哪些多路复用-io" aria-hidden="true">#</a> 有哪些多路复用 IO？</h4><p>目前流程的多路复用 IO 实现主要包括四种: <code>select</code>、<code>poll</code>、<code>epoll</code>、<code>kqueue</code>。下表是他们的一些重要特性的比较:</p><table><thead><tr><th>IO 模型</th><th>相对性能</th><th>关键思路</th><th>操作系统</th><th>JAVA 支持情况</th></tr></thead><tbody><tr><td>select</td><td>较高</td><td>Reactor</td><td>windows/Linux</td><td>支持,Reactor 模式(反应器设计模式)。Linux 操作系统的 kernels 2.4 内核版本之前，默认使用 select；而目前 windows 下对同步 IO 的支持，都是 select 模型</td></tr><tr><td>poll</td><td>较高</td><td>Reactor</td><td>Linux</td><td>Linux 下的 JAVA NIO 框架，Linux kernels 2.6 内核版本之前使用 poll 进行支持。也是使用的 Reactor 模式</td></tr><tr><td>epoll</td><td>高</td><td>Reactor/Proactor</td><td>Linux</td><td>Linux kernels 2.6 内核版本及以后使用 epoll 进行支持；Linux kernels 2.6 内核版本之前使用 poll 进行支持；另外一定注意，由于 Linux 下没有 Windows 下的 IOCP 技术提供真正的 异步 IO 支持，所以 Linux 下使用 epoll 模拟异步 IO</td></tr><tr><td>kqueue</td><td>高</td><td>Proactor</td><td>Linux</td><td>目前 JAVA 的版本不支持</td></tr></tbody></table><p>多路复用 IO 技术最适用的是“高并发”场景，所谓高并发是指 1 毫秒内至少同时有上千个连接请求准备好。其他情况下多路复用 IO 技术发挥不出来它的优势。另一方面，使用 JAVA NIO 进行功能实现，相对于传统的 Socket 套接字实现要复杂一些，所以实际应用中，需要根据自己的业务需求进行技术选择。</p><h4 id="什么是信号驱动-io" tabindex="-1"><a class="header-anchor" href="#什么是信号驱动-io" aria-hidden="true">#</a> 什么是信号驱动 IO？</h4><p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。</p><p>相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。</p><ul><li><strong>举例理解</strong></li></ul><p>你早上去买现炸油条，门口排队的人多，现在引入了一个叫号系统，点完单后你就可以做自己的事情了，然后等叫号就去拿就可以了。（所以不用再去自己频繁跑去问有没有做好了）</p><ul><li><strong>Linux 中 IO 图例</strong></li></ul><p><img src="https://exchange-imgs2021.oss-cn-beijing.aliyuncs.com/img/20220404214231.png" alt=""></p><h4 id="什么是异步-io" tabindex="-1"><a class="header-anchor" href="#什么是异步-io" aria-hidden="true">#</a> 什么是异步 IO？</h4><p>相对于同步 IO，异步 IO 不是顺序执行。用户进程进行 aio_read 系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。等到 socket 数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。IO 两个阶段，进程都是非阻塞的。</p><ul><li><strong>举例理解</strong></li></ul><p>你早上去买现炸油条， 不用去排队了，打开美团外卖下单，然后做其它事，一会外卖自己送上门。(你就是应用级别，店家就是操作系统级别, 应用无需阻塞，这就是非阻塞；系统还可能在处理中，但是立刻响应了应用，这就是异步)</p><ul><li><strong>Linux 中 IO 图例</strong></li></ul><p>（Linux 提供了 AIO 库函数实现异步，但是用的很少。目前有很多开源的异步 IO 库，例如 libevent、libev、libuv）</p><p><img src="https://exchange-imgs2021.oss-cn-beijing.aliyuncs.com/img/20220404214253.png" alt=""></p><h4 id="什么是-reactor-模型" tabindex="-1"><a class="header-anchor" href="#什么是-reactor-模型" aria-hidden="true">#</a> 什么是 Reactor 模型？</h4><p>大多数网络框架都是基于 Reactor 模型进行设计和开发，Reactor 模型基于事件驱动，特别适合处理海量的 I/O 事件。</p><ul><li><strong>传统的 IO 模型</strong>？</li></ul><p>这种模式是传统设计，每一个请求到来时，大致都会按照：请求读取-&gt;请求解码-&gt;服务执行-&gt;编码响应-&gt;发送答复 这个流程去处理。</p><p><img src="https://exchange-imgs2021.oss-cn-beijing.aliyuncs.com/img/20220404214318.png" alt=""></p><p>服务器会分配一个线程去处理，如果请求暴涨起来，那么意味着需要更多的线程来处理该请求。若请求出现暴涨，线程池的工作线程数量满载那么其它请求就会出现等待或者被抛弃。若每个小任务都可以使用非阻塞的模式，然后基于异步回调模式。这样就大大提高系统的吞吐量，这便引入了 Reactor 模型。</p><ul><li><strong>Reactor 模型中定义的三种角色</strong>：</li></ul><ol><li><strong>Reactor</strong>：负责监听和分配事件，将 I/O 事件分派给对应的 Handler。新的事件包含连接建立就绪、读就绪、写就绪等。</li><li><strong>Acceptor</strong>：处理客户端新连接，并分派请求到处理器链中。</li><li><strong>Handler</strong>：将自身与事件绑定，执行非阻塞读/写任务，完成 channel 的读入，完成处理业务逻辑后，负责将结果写出 channel。可用资源池来管理。</li></ol><ul><li><strong>单 Reactor 单线程模型</strong></li></ul><p>Reactor 线程负责多路分离套接字，accept 新连接，并分派请求到 handler。Redis 使用单 Reactor 单进程的模型。</p><p><img src="https://exchange-imgs2021.oss-cn-beijing.aliyuncs.com/img/20220404214724.png" alt=""></p><p>消息处理流程：</p><ol><li>Reactor 对象通过 select 监控连接事件，收到事件后通过 dispatch 进行转发。</li><li>如果是连接建立的事件，则由 acceptor 接受连接，并创建 handler 处理后续事件。</li><li>如果不是建立连接事件，则 Reactor 会分发调用 Handler 来响应。</li><li>handler 会完成 read-&gt;业务处理-&gt;send 的完整业务流程。</li></ol><ul><li><strong>单 Reactor 多线程模型</strong></li></ul><p>将 handler 的处理池化。</p><p><img src="https://exchange-imgs2021.oss-cn-beijing.aliyuncs.com/img/20220404214743.png" alt=""></p><ul><li><strong>多 Reactor 多线程模型</strong></li></ul><p>主从 Reactor 模型： 主 Reactor 用于响应连接请求，从 Reactor 用于处理 IO 操作请求，读写分离了。</p><p><img src="https://exchange-imgs2021.oss-cn-beijing.aliyuncs.com/img/20220404214815.png" alt=""></p><h4 id="什么是-java-nio" tabindex="-1"><a class="header-anchor" href="#什么是-java-nio" aria-hidden="true">#</a> 什么是 Java NIO？</h4><p>NIO 主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector。<strong>传统 IO 基于字节流和字符流进行操作</strong>，而<strong>NIO 基于 Channel 和 Buffer(缓冲区)进行操作</strong>，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择区)用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。</p><p>NIO 和传统 IO（一下简称 IO）之间第一个最大的区别是，IO 是面向流的，NIO 是面向缓冲区的。</p><p><img src="https://exchange-imgs2021.oss-cn-beijing.aliyuncs.com/img/20220404214845.png" alt=""></p><h3 id="_4-3-零拷贝" tabindex="-1"><a class="header-anchor" href="#_4-3-零拷贝" aria-hidden="true">#</a> 4.3 零拷贝</h3><h4 id="传统的-io-存在什么问题-为什么引入零拷贝的" tabindex="-1"><a class="header-anchor" href="#传统的-io-存在什么问题-为什么引入零拷贝的" aria-hidden="true">#</a> 传统的 IO 存在什么问题？为什么引入零拷贝的？</h4><p>如果服务端要提供文件传输的功能，我们能想到的最简单的方式是：将磁盘上的文件读取出来，然后通过网络协议发送给客户端。</p><p>传统 I/O 的工作方式是，数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的 I/O 接口从磁盘读取或写入。</p><p>代码通常如下，一般会需要两个系统调用：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token function">read</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> tmp_buf<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">write</span><span class="token punctuation">(</span>socket<span class="token punctuation">,</span> tmp_buf<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>代码很简单，虽然就两行代码，但是这里面发生了不少的事情。</p><p><img src="https://exchange-imgs2021.oss-cn-beijing.aliyuncs.com/img/20220404214918.png" alt=""></p><p>首先，<strong>期间共发生了 4 次用户态与内核态的上下文切换</strong>，因为发生了两次系统调用，一次是 read() ，一次是 write()，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。</p><p>上下文切换到成本并不小，一次切换需要耗时几十纳秒到几微秒，虽然时间看上去很短，但是在高并发的场景下，这类时间容易被累积和放大，从而影响系统的性能。</p><p>其次，还发生了 <strong>4 次数据拷贝</strong>，其中<strong>两次是 DMA 的拷贝</strong>，另外<strong>两次则是通过 CPU 拷贝</strong>的，下面说一下这个过程：</p><ul><li><strong>第一次拷贝</strong>，把磁盘上的数据拷贝到操作系统内核的缓冲区里，这个拷贝的过程是通过 DMA 搬运的。</li><li><strong>第二次拷贝</strong>，把内核缓冲区的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 CPU 完成的。</li><li><strong>第三次拷贝</strong>，把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里，这个过程依然还是由 CPU 搬运的。</li><li><strong>第四次拷贝</strong>，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的。</li></ul><p>我们回过头看这个文件传输的过程，我们只是搬运一份数据，结果却搬运了 4 次，过多的数据拷贝无疑会消耗 CPU 资源，大大降低了系统性能。</p><p>这种简单又传统的文件传输方式，存在冗余的上文切换和数据拷贝，在高并发系统里是非常糟糕的，多了很多不必要的开销，会严重影响系统性能。</p><p>所以，<strong>要想提高文件传输的性能，就需要减少「用户态与内核态的上下文切换」和「内存拷贝」的次数</strong>。</p><h4 id="mmap-write-怎么实现的零拷贝" tabindex="-1"><a class="header-anchor" href="#mmap-write-怎么实现的零拷贝" aria-hidden="true">#</a> mmap + write 怎么实现的零拷贝？</h4><p>在前面我们知道，read() 系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，于是为了减少这一步开销，我们可以用 mmap() 替换 read() 系统调用函数。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>buf <span class="token operator">=</span> <span class="token function">mmap</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">write</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>mmap() 系统调用函数会直接把内核缓冲区里的数据「映射」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。</p><p><img src="https://exchange-imgs2021.oss-cn-beijing.aliyuncs.com/img/20220404215008.png" alt=""></p><p>具体过程如下：</p><ul><li>应用进程调用了 mmap() 后，DMA 会把磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系统内核「共享」这个缓冲区；</li><li>应用进程再调用 write()，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在内核态，由 CPU 来搬运数据；</li><li>最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的。</li></ul><p>我们可以得知，通过使用 mmap() 来代替 read()， 可以减少一次数据拷贝的过程。</p><p>但这还不是最理想的零拷贝，因为仍然需要通过 CPU 把内核缓冲区的数据拷贝到 socket 缓冲区里，而且仍然需要 4 次上下文切换，因为系统调用还是 2 次。</p><h4 id="sendfile-怎么实现的零拷贝" tabindex="-1"><a class="header-anchor" href="#sendfile-怎么实现的零拷贝" aria-hidden="true">#</a> sendfile 怎么实现的零拷贝？</h4><p>在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用函数 sendfile()，函数形式如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>
<span class="token class-name">ssize_t</span> <span class="token function">sendfile</span><span class="token punctuation">(</span><span class="token keyword">int</span> out_fd<span class="token punctuation">,</span> <span class="token keyword">int</span> in_fd<span class="token punctuation">,</span> <span class="token class-name">off_t</span> <span class="token operator">*</span>offset<span class="token punctuation">,</span> <span class="token class-name">size_t</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>它的前两个参数分别是目的端和源端的文件描述符，后面两个参数是源端的偏移量和复制数据的长度，返回值是实际复制数据的长度。</p><p>首先，它可以替代前面的 read() 和 write() 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销。</p><p>其次，该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝。如下图：</p><p><img src="https://exchange-imgs2021.oss-cn-beijing.aliyuncs.com/img/20220404215050.png" alt=""></p><p>但是这还不是真正的零拷贝技术，如果网卡支持 SG-DMA（<strong>The Scatter-Gather Direct Memory Access</strong>）技术（和普通的 DMA 有所不同），我们可以进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程。</p><p>你可以在你的 Linux 系统通过下面这个命令，查看网卡是否支持 scatter-gather 特性：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>$ ethtool <span class="token operator">-</span>k eth0 <span class="token operator">|</span> grep scatter<span class="token operator">-</span>gather
scatter<span class="token operator">-</span>gather<span class="token operator">:</span> on
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>于是，从 Linux 内核 2.4 版本开始起，对于支持网卡支持 SG-DMA 技术的情况下， sendfile() 系统调用的过程发生了点变化，具体过程如下：</p><ul><li>第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里；</li><li>第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝；</li></ul><p>所以，这个过程之中，只进行了 2 次数据拷贝，如下图：</p><p><img src="https://exchange-imgs2021.oss-cn-beijing.aliyuncs.com/img/20220404215115.png" alt=""></p><p>这就是所谓的<strong>零拷贝（Zero-copy）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的</strong>。</p><p>零拷贝技术的文件传输方式相比传统文件传输的方式，<strong>减少了 2 次上下文切换和数据拷贝次数，只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运</strong>。</p>`,144),o=[i];function p(l,r){return a(),s("div",null,o)}const u=n(t,[["render",p],["__file","java-interview-three.html.vue"]]);export{u as default};
