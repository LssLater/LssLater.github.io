import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as s,e as t}from"./app-9Gb0doIl.js";const n={},r=t('<h3 id="_1-什么是散列表" tabindex="-1"><a class="header-anchor" href="#_1-什么是散列表" aria-hidden="true">#</a> 1. 什么是散列表</h3><p><strong>散列表</strong>也叫作哈希表（hash table），这种数据结构提供了键（Key）和值（Value）的映射关系。只要给出一个Key，就可以高效查找到它所匹配的Value，时间复杂度接近于O（1）。</p><p>散列表在本质上也是一个数组，可是数组只能根据下标，像a[0]、a[1]、a[2]、a[3]、a[4]这样来访问，而散列表的Key则是以字符串类型为主的。例如以学生的学号作为Key，输入002123，查询到李四；或者以单词为Key，输入by，查询到数字46……</p><p>所以我们需要一个“中转站”，通过某种方式，把Key和数组下标进行转换。这个中转站就叫作哈希函数。</p><img src="https://exchange-imgs2021.oss-cn-beijing.aliyuncs.com/img/image-20221214180712405.png" alt="image-20221214180712405" style="zoom:67%;"><p>通过哈希函数，我们可以把字符串或其他类型的Key，转化成数组的下标index。 如给出一个长度为8的数组，则当key=001121时， <code>index=HashCode (＂001121＂)%Array.length=1420036703%8=7</code> 而当key=this时， <code>index=HashCode (＂this＂)%Array.length=3559070%8=6</code></p><h3 id="_2-散列表的读写操作" tabindex="-1"><a class="header-anchor" href="#_2-散列表的读写操作" aria-hidden="true">#</a> 2.散列表的读写操作</h3><p><strong>1.写操作</strong></p><p>写操作就是在散列表中插入新的键值对。</p><p>具体步骤：</p><ul><li>第1步，通过哈希函数，把key转换成数组下标5。</li><li>第2步，如果数组下标5对应的位置没有元素，就把这个Entry填充到数组下标5的位置。</li></ul><p>但是，由于数组的长度是有限的，当插入的Entry越来越多时，不同的Key通过哈希函数获得的下标有可能是相同的。例如002936这个Key对应的数组下标是2；002947这个Key对应的数组下标也是2。这种情况叫做<strong>哈希冲突</strong></p><img src="https://exchange-imgs2021.oss-cn-beijing.aliyuncs.com/img/image-20221214181807237.png" alt="image-20221214181807237" style="zoom:67%;"><p>解决哈希冲突主要有两种方法：</p><ul><li>开放寻址法</li><li>链表法</li></ul><p><strong>开放寻址法原理</strong>：，当一个Key通过哈希函数获得对应的数组下标已被占用时，我们可以“另谋高就”，寻找下一个空档位置，直到找到没有被占用的。在Java中，ThreadLocal所使用的就是开放寻址法。</p><p><strong>链表法</strong>：HashMap数组的每一个元素不仅是一个Entry对象，还是一个链表的头节点。每一个Entry对象通过next指针指向它的下一个Entry节点。当新来的Entry映射到与之冲突的数组位置时，只需要插入到对应的链表中即可。这种方法被应用在了Java的集合类HashMap当中。</p><p><strong>2.读操作</strong></p><p>链表法：</p><ul><li>第1步，通过哈希函数，把Key转化成数组下标2。</li><li>第2步，找到数组下标2所对应的元素，如果这个元素的Key是002936，那么就找到了；如果这个Key不是002936也没关系，由于数组的每个元素都与一个链表对应，我们可以顺着链表慢慢往下找，看看能否找到与Key相匹配的节点。</li></ul><img src="https://exchange-imgs2021.oss-cn-beijing.aliyuncs.com/img/image-20221214184004716.png" alt="image-20221214184004716" style="zoom:67%;"><p>在上图中，首先查到的节点Entry6的Key是002947，和待查找的Key 002936不符。接着定位到链表下一个节点Entry1，发现Entry1的Key 002936正是我们要寻找的，所以返回Entry1的Value即可。</p><p><strong>3.扩容（resize）</strong></p><p>当经过多次元素插入，散列表达到一定饱和度时，Key映射位置发生冲突的概率会逐渐提高。这样一来，大量元素拥挤在相同的数组下标位置，形成很长的链表，对后续插入操作和查询操作的性能都有很大影响。</p><img src="https://exchange-imgs2021.oss-cn-beijing.aliyuncs.com/img/image-20221214185112156.png" alt="image-20221214185112156" style="zoom:61%;"><p>对于JDK中的散列表实现类HashMap来说，影响其扩容的因素有两个。</p><ul><li>· <strong>Capacity</strong>，即HashMap的当前长度</li><li>· LoadFactor，即HashMap的负载因子，默认值为0.75f</li></ul><p>衡量HashMap需要进行扩容的条件如下。<strong>HashMap.Size＞=Capacity×LoadFactor</strong></p><p><strong>散列表的扩容操作步骤：</strong></p><ul><li>1.扩容，创建一个新的Entry空数组，长度是原数组的2倍。</li><li>2.重新Hash，遍历原Entry数组，把所有的Entry重新Hash到新数组中。为什么要重新Hash呢？因为长度扩大以后，Hash的规则也随之改变</li></ul><h3 id="_3-小结" tabindex="-1"><a class="header-anchor" href="#_3-小结" aria-hidden="true">#</a> 3.小结</h3><p><strong>什么是数组</strong> 数组是由有限个相同类型的变量所组成的有序集合，它的物理存储方式是顺序存储，访问方式是随机访问。利用下标查找数组元素的时间复杂度是O（1），中间插入、删除数组元素的时间复杂度是O（n）。 <strong>什么是链表</strong> 链表是一种链式数据结构，由若干节点组成，每个节点包含指向下一节点的指针。链表的物理存储方式是随机存储，访问方式是顺序访问。查找链表节点的时间复杂度是O（n），中间插入、删除节点的时间复杂度是O（1）。 <strong>什么是栈</strong> 栈是一种线性逻辑结构，可以用数组实现，也可以用链表实现。栈包含入栈和出栈操作，遵循先入后出的原则（FILO）。 <strong>什么是队列</strong> 队列也是一种线性逻辑结构，可以用数组实现，也可以用链表实现。队列包含入队和出队操作，遵循先入先出的原则（FIFO）。</p><p><strong>什么是散列表</strong> 散列表也叫哈希表，是存储Key-Value映射的集合。对于某一个Key，散列表可以在接近O（1）的时间内进行读写操作。散列表通过哈希函数实现Key和数组下标的转换，通过开放寻址法和链表法来解决哈希冲突。</p>',33),i=[r];function o(g,l){return a(),s("div",null,i)}const c=e(n,[["render",o],["__file","Hash-Table.html.vue"]]);export{c as default};
